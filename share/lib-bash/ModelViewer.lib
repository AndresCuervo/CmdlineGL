# ModelView API
#--------------------------------------
#
# This module sets up the translations and handles user input to give the
# effect of a camera looking at a model, which you then render at the origin.
#
# Functions
#   ModelViewer_DispatchEvent EVENT [PARAM...]
#   ModelViewer_Update
#   ModelViewer_ApplyMatrix
# Variables
#   ModelViewer_PanDegPerSec - Number of degrees to rotate per second of continual up/down/left/right keypress
#   ModelViewer_ZoomPctPerSec - Percentage of distance to model which we will travel in one second
#   ModelViewer_Distance   - Initial camera distance from the model
#   ModelViewer_Pitch      - Initial camera vertical angle above the model
#   ModelViewer_Direction  - Initial camera sideways angle around the model
#

CmdlineGL_LoadLib Timing FixedPt

ModelViewer_Distance=10000
ModelViewer_Pitch=0
ModelViewer_Direction=0

ModelViewer_MDrag=0
ModelViewer_Left=0
ModelViewer_Right=0
ModelViewer_Up=0
ModelViewer_Down=0
ModelViewer_In=0
ModelViewer_Out=0
ModelViewer_PanDegPerSec=90
ModelViewer_ZoomPctPerSec=20

# DispatchEvent returns true if it consumed the event, false otherwise.
# Positonal arguments are as received from CmdlineGL
ModelViewer_DispatchEvent() {
	(( $# > 0 )) || return 1
	local Press
	case "$1" in
	K)
		if [[ "$2" == + ]]; then Press=1; else Press=0; fi
		case "$3" in
		right) ((ModelViewer_Right= Press));;
		left)  ((ModelViewer_Left=  Press));;
		up)    ((ModelViewer_Up=    Press));;
		down)  ((ModelViewer_Down=  Press));;
		=)     ((ModelViewer_In=    Press));;
		-)     ((ModelViewer_Out=   Press));;
		*)     return 1;; # not consumed
		esac
		return 0 # consumed
		;;
	M)
		case "$2" in
		@)
			local dx="$5" dy="$6";
			# Handle mouse drag actions.
			# If the mouse has moved since last time change the pitch or direction
			# by the vertical or horizontal distance the mouse has moved.
			if ((ModelViewer_MDrag)); then
				((ModelViewer_Pitch+= dy*1000))
				((ModelViewer_Direction+= dx*1000));
				return 0 # consumed
			fi
			;;
		+)
			if [[ "$3" == 1 ]]; then
				ModelViewer_MDrag=1
				return 0 # consumed
			fi;;
		-)
			if [[ "$3" == 1 ]]; then
				ModelViewer_MDrag=0
				return 0 # consumed
			fi;;
		esac
		return 1 # not consumed
		;;
	esac
}

ModelViewer_Update() {
	# All numbers are scaled by 1000 to match time reported in milliseconds
	((ModelViewer_Left))  && ((ModelViewer_Direction+=Timing_dT*ModelViewer_PanDegPerSec))
	((ModelViewer_Right)) && ((ModelViewer_Direction-=Timing_dT*ModelViewer_PanDegPerSec))
	((ModelViewer_Up))    && ((ModelViewer_Pitch-=Timing_dT*ModelViewer_PanDegPerSec))
	((ModelViewer_Down))  && ((ModelViewer_Pitch+=Timing_dT*ModelViewer_PanDegPerSec))
	local Zoom;
	((Zoom=ModelViewer_In? ( ModelViewer_Out? 0 : -1 ) : ModelViewer_Out? 1 : 0))
	((Zoom*= ModelViewer_ZoomPctPerSec*ModelViewer_Distance/100))
	((ModelViewer_Distance += Zoom))
	((ModelViewer_Distance>0)) || ((ModelViewer_Distance=1))
}

ModelViewer_ApplyMatrix() {
	# Alter the model matrix to give the effect of having a movable camera.
	glTranslate 0 0 -$((ModelViewer_Distance*FixedPt/1000))
	glRotate $((ModelViewer_Pitch*FixedPt/1000)) $((FixedPt)) 0 0
	glRotate $((ModelViewer_Direction*FixedPt/1000)) 0 $((FixedPt)) 0
}
