#! /usr/bin/env perl

=head1 DESCRIPTION

Generates static hash table of commands by parsing C source.

=cut

use strict;
use warnings;

my @commands;

while (<STDIN>) {
	# Look for COMMAND(cmd, "args")
	push @commands, { name => $1, arg_format => $2 }
		if ($_ =~ m|^\s*COMMAND\s*\(\s*(\S+)\s*,\s*"(\S*)"\s*\)|);
}
@commands= sort { $a->{name} cmp $b->{name} } @commands;

# table size is 1.5 x number of entries rounded up to power of 2.
my $mask= int(2 * @commands);
$mask |= $mask >> 1;
$mask |= $mask >> 2;
$mask |= $mask >> 4;
$mask |= $mask >> 8;
$mask |= $mask >> 16;
my $scan_dist= 1;
my $table_size= $mask+1+$scan_dist;

sub build_table {
	my ($mul, $shift)= @_;
	my @table= (0) x $table_size;
	name: for my $ci (0..$#commands) {
		my $bucket= hash_fn($commands[$ci]{name}, $mul, $shift);
		for (0..$scan_dist) {
			if (!$table[$bucket+$_]) {
				$table[$bucket+$_]= $ci+1; # 1-based
				next name;
			}
		}
		return undef;
	}
	return \@table;
}

sub find_collisionless_hash_params {
	# pick factors for the hash function until each command has a unique bucket
	for (my $mul= 1; $mul < $table_size*$table_size; $mul++) {
		for (my $shift= 1; $shift < 11; $shift++) {
			my $table= build_table($mul, $shift);
			return ( $table, $mul, $shift )
				if $table;
		}
	}
	die "No value of \$shift / \$mul results in unique codes for each command\n";
}

my ($table, $mul, $shift)= find_collisionless_hash_params();

my $cmd_prototypes= join '', map "extern bool cmd_$_->{name}(struct ParseParamsResult *parsed);\n", @commands;
my $i= 1;
my $list_items=     join '', map sprintf(qq|/* %4d */ { "%s", "%s", cmd_%s },\n|, $i++, $_->{name}, $_->{arg_format}, $_->{name}), @commands;
my $hash_entries= '';
for (0..$#$table) {
	$hash_entries .= "\n" if $_ && !($_ & 0xF);
	$hash_entries .= sprintf(" %4d,", $table->[$_]);
}

# This must be kept in sync with the C version.
# Use a mask similar to a 32-bit register's effect to make sure Perl
# behaves the same way as C regardless of Perl's integer width, and
# then tell C to explicitly use 32-bit math.
sub hash_fn {
	my ($string, $mul, $shift)= @_;
	use integer;
	my $i32_mask= (1<<(32-$shift))-1;
	my $x= 0;
	for (unpack( 'C' x length($string), $string )) {
		$x= ((($x * $mul) >> $shift) & $i32_mask) + $_;
	}
	return $x & $mask;
}

print <<END;
// File generated by $0
//
// $#commands commands
// table size is $table_size, mul is $mul, shift is $shift
#include "config.h"
#include <inttypes.h>
#include <string.h>
#include "ProcessInput.h"
#include "SymbolHash.h"

int CmdHashFunc(const char *name) {
	uint32_t x= 0;
	while (*name)
		x= ((x * $mul) >> $shift) + (*name++ & 0xFF);
	return x & $mask;
}

$cmd_prototypes

const int CmdListCount= $#commands;
const CmdListEntry CmdList[]= {
	{ NULL, NULL, NULL },
$list_items
	{ NULL, NULL, NULL },
};
const int CmdHashTableSize= $table_size;
const uint16_t CmdHashTable[]= {
$hash_entries
	0
};

const CmdListEntry *GetCmd(const char *Name) {
	int code= CmdHashFunc(Name);
	int lim= code + $scan_dist + 1;
	/* scan forward at most $scan_dist table entries looking for the given Name.
	 * No need to wrap, because the table is longer than the hash function mask. */
	while (code < lim) {
		if (CmdHashTable[code] && strcmp(CmdList[CmdHashTable[code]].Name, Name) == 0)
			return &CmdList[CmdHashTable[code]];
		code++;
	}
	return NULL;
}

END
